#!/usr/bin/python3

"""
key2bits.py will transform a binary layout of a key ROM into a set of bits that should be replaced in
a Spartan-7 bitstream to program the desired key into an FPGA.

The implementation will read in a tilegrid.json and a segbits_clbll_l.db file, as generated by
prjxray, as well as a rom.db file generated by betrusted-soc.py that specifies the mapping of ROM LUTs
to SLICE/BELs, and contains the hard-offset of the frame sequence that would contain the ROM array.

This layout data is combined wth a key.bin file which contains an 8kbit array of key material,
organized as 32-bit little endian words.

There are two types of output from this program:

1. An ascii file containing a set of (offset, byte) pairs that specify the patching offset, in bytes, from the
start of the "type2" frames within the bitstream to insert the ROM pattern. This can be paired wth another
utility that applies the patch thus resulting in a .bin file that can be burned into an FPGA.

2. A Rust function which reads in the key data from a "key: [u32; 256]" array, and given an offset
from the start of a "type2" config frame run return either None for no patching, or the byte to replace at
that offset to insert the key into a bitstream.

The first type of output is used to validate that this code works through manual benching. The second
type of output is meant to be copied into the bitstream encryption routine inside Betrusted to accomplish
the key insertion.

By allowing the striping of the key data to be specified in a rom.db file, the bitstream patching algorithm
can be updated in the case that later on the position of the key LUTs need to be changed for better fitting
into the FPGA.


MAPPING KEY->LUT

The ROM is implemented in hardware as a 256 entry x 32-bit wide ROM. There are 128 ROM LUTs, and each ROM LUT
maps to one bit of the key ROM. So, KEYROM0* is bit 0, KEYROM1* is bit 1, and so forth. The KEYROMs are further
broken down into A-D BEL positions, with "A" position corresponding to bits [63:0], "B" to bits [127:64],
"C" to bits [191:128], and "D" to bits [255:192]. Within each LUT, the INIT value maps the lower six bits
of the address, with address 0 corresponding to the LSB, and address 255 corresponding to the MSB.

Thus the key data as presented in "program order" needs to be tilted on its side and bit-striped into the
key array a bit like the following highly simplified example:

word 0       word 1       word 2       word 3
A0 A1 A2 A3  B0 B1 B2 B3  C0 C1 C2 C3  D0 D1 D2 D3

KEYROM0 LUT: D0 C0 B0 A0
KEYROM1 LUT: D1 C1 B1 A1
KEYROM2 LUT: D2 C2 B2 A2
KEYROM3 LUT: D3 C3 B3 A3

"""

if __name__ == "__main__":
    main()
